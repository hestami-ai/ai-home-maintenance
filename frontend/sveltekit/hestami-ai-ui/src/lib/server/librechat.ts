/**
 * LibreChat API Integration Module
 * 
 * Handles authentication translation and request proxying between SvelteKit
 * and LibreChat API. Manages LibreChat session cookies in Redis.
 */
import { env } from '$env/dynamic/private';
import { getRedisClient } from './redis';
import type { Cookies } from '@sveltejs/kit';
import { API_BASE_URL } from './auth';

export const LIBRECHAT_BASE_URL = env.LIBRECHAT_API_URL || 'http://librechat:3080';

/**
 * Get LibreChat session cookie from Redis
 * 
 * @param sessionId - SvelteKit session ID
 * @returns LibreChat session cookie string or null if not found
 */
export async function getLibreChatSession(sessionId: string): Promise<string | null> {
  try {
    const redis = await getRedisClient();
    const session = await redis.get(`session:${sessionId}:librechat`);
    return session;
  } catch (error) {
    console.error('Error getting LibreChat session:', error);
    return null;
  }
}

/**
 * Store LibreChat session cookie in Redis
 * 
 * @param sessionId - SvelteKit session ID
 * @param librechatSession - LibreChat session cookie string
 * @returns Success status
 */
export async function setLibreChatSession(
  sessionId: string, 
  librechatSession: string
): Promise<boolean> {
  try {
    const redis = await getRedisClient();
    await redis.set(
      `session:${sessionId}:librechat`,
      librechatSession,
      { EX: 86400 } // 24 hours
    );
    return true;
  } catch (error) {
    console.error('Error setting LibreChat session:', error);
    return false;
  }
}

/**
 * Authenticate with LibreChat using user credentials
 * 
 * @param email - User's email address
 * @param password - LibreChat password (generated by Django)
 * @returns All LibreChat cookies as a single cookie string, or null if failed
 */
export async function authenticateLibreChat(
  email: string,
  password: string
): Promise<string | null> {
  try {
    console.log(`Authenticating with LibreChat for ${email}`);
    
    const response = await fetch(`${LIBRECHAT_BASE_URL}/api/auth/login`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ email, password })
    });
    
    if (!response.ok) {
      console.error(`LibreChat authentication failed: ${response.status} ${response.statusText}`);
      return null;
    }
    
    // Get the access token from response body
    const responseData = await response.json();
    const accessToken = responseData.token;
    
    if (!accessToken) {
      console.error('[authenticateLibreChat] No access token in response body');
      return null;
    }
    
    console.log('[authenticateLibreChat] Access token received (first 50 chars):', accessToken.substring(0, 50));
    
    // Extract all cookies from Set-Cookie headers
    // LibreChat uses JWT tokens in cookies (refreshToken, token_provider)
    const setCookieHeaders = response.headers.getSetCookie();
    console.log('[authenticateLibreChat] Set-Cookie headers:', setCookieHeaders);
    
    if (!setCookieHeaders || setCookieHeaders.length === 0) {
      console.error('No cookies in LibreChat response');
      return null;
    }
    
    // Parse all cookies and combine them
    const cookies: string[] = [];
    for (const setCookie of setCookieHeaders) {
      const cookieParts = setCookie.split(';');
      const cookieValue = cookieParts[0].trim();
      if (cookieValue) {
        console.log('[authenticateLibreChat] Parsed cookie:', cookieValue.substring(0, 50) + '...');
        cookies.push(cookieValue);
      }
    }
    
    // Add the access token as a special cookie entry so we can extract it later
    cookies.push(`accessToken=${accessToken}`);
    
    if (cookies.length > 0) {
      const cookieString = cookies.join('; ');
      console.log(`[authenticateLibreChat] Successfully authenticated with LibreChat for ${email}`);
      console.log(`[authenticateLibreChat] Final cookie string (first 200 chars):`, cookieString.substring(0, 200));
      return cookieString;
    }
    
    console.error('Could not parse LibreChat cookies');
    return null;
  } catch (error) {
    console.error('LibreChat authentication error:', error);
    return null;
  }
}

/**
 * Ensure LibreChat session exists, creating it if necessary
 * 
 * @param sessionId - SvelteKit session ID
 * @param userEmail - User's email address
 * @returns LibreChat session cookie string or null if failed
 */
export async function ensureLibreChatSession(
  sessionId: string,
  userEmail: string
): Promise<string | null> {
  try {
    // Check if LibreChat session already exists
    let librechatSession = await getLibreChatSession(sessionId);
    
    if (librechatSession) {
      console.log(`[ensureLibreChatSession] Using existing session for ${userEmail}`);
      return librechatSession;
    }
    
    // No session exists, create one
    console.log(`[ensureLibreChatSession] Creating LibreChat session for ${userEmail}`);
    
    // Get LibreChat password from Django
    const librechatPassword = await getLibreChatPasswordFromDjango(sessionId);
    
    if (!librechatPassword) {
      console.error('Failed to get LibreChat password from Django');
      return null;
    }
    
    // Authenticate with LibreChat
    librechatSession = await authenticateLibreChat(userEmail, librechatPassword);
    
    if (!librechatSession) {
      console.error('Failed to authenticate with LibreChat');
      return null;
    }
    
    // Store session in Redis
    await setLibreChatSession(sessionId, librechatSession);
    console.log(`LibreChat session created and stored for ${userEmail}`);
    
    return librechatSession;
  } catch (error) {
    console.error('Error ensuring LibreChat session:', error);
    return null;
  }
}

/**
 * Make authenticated request to LibreChat API
 * 
 * @param sessionId - SvelteKit session ID
 * @param path - API endpoint path (e.g., "/api/conversations")
 * @param options - Fetch options
 * @param userEmail - User email for re-authentication if session expired
 * @returns Fetch response
 */
export async function librechatRequest(
  sessionId: string,
  path: string,
  options: RequestInit = {},
  userEmail?: string
): Promise<Response> {
  try {
    console.log('[librechatRequest] Making request to:', path);
    
    // Get LibreChat session from Redis
    let librechatSession = await getLibreChatSession(sessionId);
    
    if (!librechatSession) {
      console.error('[librechatRequest] No LibreChat session in Redis');
      throw new Error('No LibreChat session available');
    }
    
    console.log('[librechatRequest] LibreChat session found:', librechatSession.substring(0, 100) + '...');
    
    // Extract access token for Authorization header
    // LibreChat's /api/agents endpoint requires JWT in Authorization header
    const accessTokenMatch = librechatSession.match(/accessToken=([^;]+)/);
    const jwtToken = accessTokenMatch ? accessTokenMatch[1] : null;
    
    if (jwtToken) {
      console.log('[librechatRequest] Extracted access token (first 50 chars):', jwtToken.substring(0, 50));
    } else {
      console.error('[librechatRequest] Failed to extract access token from session');
    }
    
    // Prepare headers
    let headers = new Headers(options.headers);
    headers.set('Cookie', librechatSession);
    
    // Remove Accept-Encoding to let Node.js fetch handle decompression automatically.
    // This prevents passing through Brotli-compressed responses to clients that don't support it
    // (e.g., iOS URLSession doesn't auto-decompress Brotli, only gzip/deflate).
    // SvelteKit will re-compress the response based on what the actual client supports.
    headers.delete('Accept-Encoding');
    
    // Add User-Agent header to pass LibreChat's uaParser middleware
    headers.set('User-Agent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36');
    
    // Add JWT token to Authorization header if available
    if (jwtToken) {
      headers.set('Authorization', `Bearer ${jwtToken}`);
      console.log('[librechatRequest] Added JWT to Authorization header');
    }
    
    // Don't set Content-Type for FormData (browser sets it with boundary)
    if (options.body && !(options.body instanceof FormData)) {
      if (!headers.has('Content-Type')) {
        headers.set('Content-Type', 'application/json');
      }
    }
    
    const url = `${LIBRECHAT_BASE_URL}${path}`;
    console.log('[librechatRequest] Fetching:', url);
    console.log('[librechatRequest] Method:', options.method);
    console.log('[librechatRequest] Body type:', typeof options.body);
    console.log('[librechatRequest] Body (full):', typeof options.body === 'string' ? options.body : 'FormData');
    console.log('[librechatRequest] Headers being sent:');
    headers.forEach((value, key) => {
      // Don't log full auth tokens, just show they exist
      if (key.toLowerCase() === 'authorization' || key.toLowerCase() === 'cookie') {
        console.log(`  ${key}: [REDACTED - length ${value.length}]`);
      } else {
        console.log(`  ${key}: ${value}`);
      }
    });
    
    // Make request to LibreChat
    let response = await fetch(url, {
      ...options,
      headers
    });
    
    console.log('[librechatRequest] Response status:', response.status);
    console.log('[librechatRequest] Response headers:');
    response.headers.forEach((value, key) => {
      console.log(`  ${key}: ${value}`);
    });
    
    // If 401 and we have userEmail, try to re-authenticate
    console.log('[librechatRequest] Checking re-auth conditions: status=', response.status, 'userEmail=', userEmail ? 'provided' : 'NOT PROVIDED');
    if (response.status === 401 && userEmail) {
      console.log('[librechatRequest] Session expired, re-authenticating for:', userEmail);
      
      // Clear old session from Redis
      await setLibreChatSession(sessionId, '');
      
      // Get LibreChat password from Django
      const librechatPassword = await getLibreChatPasswordFromDjango(sessionId);
      
      if (!librechatPassword) {
        console.error('[librechatRequest] Failed to get LibreChat password for re-auth');
        return response; // Return original 401 response
      }
      
      // Re-authenticate with LibreChat
      librechatSession = await authenticateLibreChat(userEmail, librechatPassword);
      
      if (!librechatSession) {
        console.error('[librechatRequest] Failed to re-authenticate with LibreChat');
        return response; // Return original 401 response
      }
      
      // Store new session in Redis
      await setLibreChatSession(sessionId, librechatSession);
      console.log('[librechatRequest] Re-authenticated successfully, retrying request');
      
      // Retry the request with new session
      // Extract access token from new session
      const retryAccessTokenMatch = librechatSession.match(/accessToken=([^;]+)/);
      const retryJwtToken = retryAccessTokenMatch ? retryAccessTokenMatch[1] : null;
      
      headers = new Headers(options.headers);
      headers.set('Cookie', librechatSession);
      
      // Add User-Agent header (required by LibreChat's uaParser middleware)
      headers.set('User-Agent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36');
      
      // Add JWT token to Authorization header
      if (retryJwtToken) {
        headers.set('Authorization', `Bearer ${retryJwtToken}`);
      }
      
      if (options.body && !(options.body instanceof FormData)) {
        if (!headers.has('Content-Type')) {
          headers.set('Content-Type', 'application/json');
        }
      }
      
      response = await fetch(url, {
        ...options,
        headers
      });
      
      console.log('[librechatRequest] Retry response status:', response.status);
    }
    
    return response;
  } catch (error) {
    console.error('[librechatRequest] Error:', error);
    throw error;
  }
}

/**
 * Upload image to LibreChat
 * 
 * @param sessionId - SvelteKit session ID
 * @param file - File to upload
 * @returns Upload result with file_id and _id, or null if failed
 */
export async function uploadImageToLibreChat(
  sessionId: string,
  file: File
): Promise<{ file_id: string; _id: string } | null> {
  try {
    const formData = new FormData();
    formData.append('file', file);
    
    const response = await librechatRequest(
      sessionId,
      '/api/files/images',
      {
        method: 'POST',
        body: formData
      }
    );
    
    if (!response.ok) {
      console.error(`LibreChat image upload failed: ${response.status} ${response.statusText}`);
      return null;
    }
    
    const data = await response.json();
    return {
      file_id: data.file_id,
      _id: data._id
    };
  } catch (error) {
    console.error('LibreChat image upload error:', error);
    return null;
  }
}

/**
 * Get LibreChat password from Django for authenticated user
 * 
 * @param sessionId - SvelteKit session ID
 * @returns LibreChat password or null if failed
 */
export async function getLibreChatPasswordFromDjango(
  sessionId: string
): Promise<string | null> {
  try {
    // Import here to avoid circular dependency
    const { getAuthTokens, refreshTokens } = await import('./auth');
    
    // Get current access token
    let tokens = await getAuthTokens(sessionId);
    if (!tokens) {
      console.error('No auth tokens found in session');
      return null;
    }
    
    // Try with current token
    let response = await fetch(`${API_BASE_URL}/api/users/librechat-password/`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${tokens.accessToken}`
      }
    });
    
    // If unauthorized, try refreshing token
    if (response.status === 401) {
      console.log('Access token expired, refreshing...');
      const refreshed = await refreshTokens(sessionId);
      
      if (!refreshed) {
        console.error('Failed to refresh access token');
        return null;
      }
      
      // Get new tokens and retry
      tokens = await getAuthTokens(sessionId);
      if (!tokens) {
        console.error('No tokens after refresh');
        return null;
      }
      
      response = await fetch(`${API_BASE_URL}/api/users/librechat-password/`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${tokens.accessToken}`
        }
      });
    }
    
    if (!response.ok) {
      console.error(`Failed to get LibreChat password from Django: ${response.status}`);
      return null;
    }
    
    const data = await response.json();
    return data.librechat_password;
  } catch (error) {
    console.error('Error fetching LibreChat password from Django:', error);
    return null;
  }
}
