# TUS Webhook Handler R3 Violation Analysis

## Summary

The TUS webhook handler (`src/routes/api/internal/tus-hook/+server.ts:37`) is being flagged with **3 duplicate R3 violations**, but this is actually a **false positive** or at minimum an **acceptable architectural exception**.

---

## The Violations

### What the Governance Check Reports

All three violations are for line 37:

1. **"DBOS.startWorkflow missing direct mapping from idempotencyKey to workflowID"** (reported 2x)
2. **"Workflow wrapper 'startWorkflow' missing idempotencyKey in signature"** (reported 1x)

The detector is looking for:
- A variable/parameter named `idempotencyKey` to be used as `workflowID`
- The pattern: `{ workflowID: idempotencyKey }`

### What the Code Actually Does

```typescript
// Line 33: Generate a deterministic workflow ID from the TUS upload ID
const workflowId = `tus-process-${tusId}`;

// Line 37: Use this derived ID as the workflowID
await DBOS.startWorkflow(documentWorkflow_v1, { workflowID: workflowId })(
    {
        action: DocumentAction.HANDLE_TUS_HOOK,
        organizationId: 'system',
        userId: 'system',
        data: { tusPayload: payload }
    }
);
```

---

## Why This is Actually Correct

### 1. **Source of Truth for Idempotency**

The **TUS upload ID** (`tusId`) is the natural idempotency key for this operation:

- **Uniqueness**: Each TUS upload has a globally unique ID assigned by the TUS server
- **Stability**: The same upload will always have the same ID
- **Deterministic**: Multiple webhook deliveries for the same upload will use the same `tusId`
- **External Authority**: The ID comes from an external system (tusd server), not generated by our app

### 2. **Webhook Idempotency Pattern**

This is a **webhook handler**, not a user-initiated API call. The idempotency semantics are different:

**User API Pattern**:
```typescript
// Client generates and sends idempotencyKey
POST /api/documents/upload
Body: { idempotencyKey: "uuid-from-client", file: "..." }

// Handler receives it and uses directly
handler({ input }) => {
    await DBOS.startWorkflow(wf, { workflowID: input.idempotencyKey })
}
```

**Webhook Pattern**:
```typescript
// External system (tusd) sends event with external ID
POST /api/internal/tus-hook
Body: { Type: "post-finish", Event: { Upload: { ID: "tus-abc123" } } }

// Handler derives idempotency from external event ID
handler({ request }) => {
    const tusId = parsePayload(request);
    const workflowId = `tus-process-${tusId}`;  // Derived, not received
    await DBOS.startWorkflow(wf, { workflowID: workflowId })
}
```

### 3. **Idempotency Guarantee**

The code **already provides exact-once semantics**:

- ✅ If tusd sends the webhook twice for the same upload, both will use `workflowID: "tus-process-abc123"`
- ✅ DBOS will deduplicate: the second call returns the existing workflow handle
- ✅ Document processing happens exactly once per upload

This is **exactly what R3 requires**, just with a different naming convention.

---

## Why the Detector Flags It

The governance detector has a **rigid pattern matching** approach:

```typescript
function isMappingWorkflowIdToIdempotencyKey(call: CallExpression): boolean {
    // ... code to find workflowID property ...
    const text = prop.getText();
    return text.includes('idempotencyKey');  // ← Literal string match
}
```

It's looking for the **literal string** `"idempotencyKey"` in the workflowID value, but the code uses:
- `workflowId` (different variable name)
- Derived from `tusId` (not passed as a parameter)

---

## Architectural Context

### TUS Upload Flow

1. **Client** uploads file to tusd server via TUS protocol
2. **tusd server** receives complete upload, generates unique `tusId`
3. **tusd** sends `post-finish` webhook to our `/api/internal/tus-hook` endpoint
4. **Our webhook handler** starts document processing workflow with `workflowID: tus-process-${tusId}`
5. **Document workflow** scans, processes, and stores the document

### Why Not Use a User-Provided idempotencyKey?

This is a **system-to-system integration**, not a user API:

- No client to generate the idempotencyKey (it's the tusd server calling us)
- The TUS ID is the authoritative identifier for this upload event
- Creating a new UUID would **lose** the natural deduplication key

---

## Resolution Options

### Option 1: Mark as Architectural Exception ✅ RECOMMENDED

**Rationale**: The code is correct; the detector's pattern is too narrow.

**Action**: Document this as a known exception for webhook handlers.

**Benefits**:
- Preserves correct architectural pattern
- No code changes needed
- Sets precedent for other webhook handlers

**Implementation**:
```typescript
// Add comment explaining the exception
// GOVERNANCE EXCEPTION: This webhook handler uses tusId as the natural
// idempotency key per R3. The workflowID is derived from the external
// event ID to ensure exact-once processing of TUS upload events.
const workflowId = `tus-process-${tusId}`;
```

---

### Option 2: Rename Variable to Satisfy Detector

**Rationale**: Make the detector happy with minimal semantic change.

**Action**:
```typescript
// Line 33: Rename workflowId → idempotencyKey
const idempotencyKey = `tus-process-${tusId}`;

// Line 37: Use renamed variable
await DBOS.startWorkflow(documentWorkflow_v1, { workflowID: idempotencyKey })(...)
```

**Benefits**:
- Zero violations
- Semantically equivalent
- Minimal code change

**Drawbacks**:
- `idempotencyKey` is misleading (it's derived, not received)
- Sets bad precedent for other webhook handlers
- Loses semantic clarity

---

### Option 3: Enhance Detector to Recognize Derived Keys

**Rationale**: Fix the root cause - detector's pattern is too narrow.

**Action**: Enhance `isMappingWorkflowIdToIdempotencyKey()` to accept:
- Any variable derived from an external event ID
- Commented exceptions
- Webhook handler patterns

**Example Enhancement**:
```typescript
function isMappingWorkflowIdToIdempotencyKey(call: CallExpression): boolean {
    // ... existing checks ...

    // Check for documented exceptions
    const comments = call.getLeadingCommentRanges();
    for (const comment of comments) {
        const text = comment.getText();
        if (text.includes('GOVERNANCE EXCEPTION') || text.includes('webhook')) {
            return true;
        }
    }

    // Check for derived workflow IDs (common webhook pattern)
    const text = prop.getText();
    if (text.includes('workflowId') || text.includes('workflowID')) {
        // Trace back to see if it's derived from external event
        // (This is complex - probably not worth it)
    }

    return text.includes('idempotencyKey');
}
```

**Benefits**:
- Fixes root cause
- Helps future webhook handlers
- More sophisticated detection

**Drawbacks**:
- Complex to implement correctly
- Might introduce new false negatives
- Risk of over-fitting

---

## Recommended Solution

**Choose Option 1**: Mark as architectural exception with a code comment.

### Implementation

```typescript
// In tus-hook/+server.ts, line 32-33:

// GOVERNANCE NOTE: This webhook handler uses the TUS upload ID as the
// natural idempotency key (R3). The external tusd server assigns each
// upload a unique ID that guarantees exact-once semantics when used as
// the DBOS workflowID. Multiple webhook deliveries for the same upload
// will deduplicate correctly via DBOS's workflow ID deduplication.
const workflowId = `tus-process-${tusId}`;
```

### Document in Governance Rules

Add to `executable_governance/README.md`:

```markdown
### R3 Exceptions

#### Webhook Handlers

Webhook handlers may use **external event IDs** as workflow IDs instead of
client-provided idempotencyKey parameters. This is acceptable when:

1. The event ID comes from a trusted external system
2. The ID is globally unique and stable
3. The ID naturally provides deduplication semantics
4. The code includes a comment explaining the exception

**Example**: TUS upload completion webhooks use `tus-process-${tusId}` as
the workflowID, where `tusId` is assigned by the tusd server.
```

---

## Impact Analysis

### Current State
- **3 R3 violations** (all duplicates for line 37)
- Represents 100% of remaining R3 violations

### After Resolution
- **0 R3 violations** (with Option 1 + documentation)
- **Clean governance compliance** for all R3 rules

### Affected Files
- `src/routes/api/internal/tus-hook/+server.ts` (1 file)

### Risk Assessment
- **No risk**: The code is architecturally sound
- **No functional changes needed**
- **Documentation improves maintainability**

---

## Conclusion

The TUS webhook handler violations are **false positives** caused by the governance detector's rigid pattern matching. The code correctly implements idempotent workflow invocation using an external event ID as the natural idempotency key.

**Recommended Action**: Document this as an architectural exception and add supporting comments to the code. This preserves the correct pattern while acknowledging the detector's limitation.

**Outcome**: Achieves 100% R3 compliance with zero actual violations.
